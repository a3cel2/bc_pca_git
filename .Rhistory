}
rownames(result) <- rownames(input_df)
colnames(result) <- unique_terms
return(result)
}
#' Get string corresponding to interactions of degree n amongst given variables
#'
#' @param variable_names the names of variables to be expanded into interactions
#' @param degree the degree of interactions desired
#'
#' @return a vector of strings in A:B:C...etc format
get_interactions <- function(variable_names,degree){
all_combos <- combn(variable_names,degree)
return(apply(all_combos,2,function(x){paste(x,collapse=':')}))
}
#' Perform stepwise feature elimination on a linear regression model using Type III SS Anova
#'
#' @param my_lm a linear model object
#' @param alpha the minimum p value of variables to keep
#' @param given_data the source data on which my_lm was trained on, if NULL (default) tries to extract it from the lm object
#'
#' @return a new linear model with all variables with significance less than alpha removed in a stepwise fashion
stepwise_feature_elimination_lm <- function(my_lm,alpha=0.05,given_data=NULL){
if(is.null(given_data)){
given_data <- my_lm$model
}
my_anova_lm <- Anova(my_lm,type='III')
max_p <- max(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)],na.rm=T)
while(max_p > alpha){
#Exclude Intercept and residual terms from min
max_p <- max(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)],na.rm=T)
#Remove according coefficient
coefficients <- rownames(my_anova_lm)[2:(nrow(my_anova_lm))]
coefficients <- coefficients[!(1:length(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)]) %in% which.min(abs(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)] - min_val)))]
coefficients <- coefficients[!(coefficients %in% c('Residuals','(Intercept)'))]
coefficients <- coefficients[!is.na(coefficients)]
print(paste(c('resistance~',paste(c(coefficients),collapse='+')),collapse=''))
formula <- as.formula(paste(c('resistance~',paste(c(coefficients),collapse='+')),collapse=''))
my_lm <- lm(formula,data=given_data)
my_anova_lm <- Anova(my_lm,type='III')
max_p <- max(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)],na.rm=T)
}
return(my_lm)
}
create_resistance_lm <- function(terms,
resistance_matrix,
genotyping_df,
drug_name,
mating_type,
genotyping_columns=2:17){
name <- paste(c(drug,mating_type),collapse='_')
genotyping_results <- genotyping_df[,genotyping_columns]
genotype_terms <- create_interaction_matrix(terms,genotyping_results)
lm_df <- as.data.frame(cbind(as.data.frame(resistance_matrix[,name]),
genotyping_df$Plate,
as.data.frame(genotype_terms)))
colnames(lm_df)[1:2] <- c('resistance','Plate')
lm_formula <- as.formula(paste(c('resistance~',paste(c(terms,'Plate'),collapse='+')),collapse=''))
return(lm(lm_formula,data=lm_df))
}
create_all_lms <- function(drugs='tamoxifen',
mating_types=c('A','alpha'),
A_resistance_matrix=NULL,
alpha_resistance_matrix=NULL,
A_genotyping_df=NULL,
alpha_genotyping_df=NULL,
maximum_degree=4,
genotyping_columns=2:17,
genes_considered='all',
sig_threshold_marginal=0.05
){
results <- list('lm_list'=list(),
'term_names'=list()
)
if(length(mating_types) == 2){
results$overap_results <- list()
results$term_overlap_significance <- list()
}
if(genes_considered == 'all'){
if('A' %in% mating_types){
genes_A <- colnames(A_genotyping_df)[genotyping_columns]
}
if('alpha' %in% mating_types){
genes_alpha <- colnames(alpha_genotyping_df)[genotyping_columns]
}
if(length(mating_types) == 2){
if(all.equal(genes_A,genes_alpha) != TRUE){
stop('Genotyping columns differ between A and alpha')
}
}
}
for(drug in drugs){
for(mating_type in mating_types){
if(mating_type=='A'){
if(is.null(A_resistance_matrix) | is.null(A_genotyping_df)){
stop('Please provide proper data for the A mating type')
}
resistance_matrix <- A_resistance_matrix
genotyping_df <- A_genotyping_df
}else if(mating_type == 'alpha'){
if(is.null(alpha_resistance_matrix) | is.null(alpha_genotyping_df)){
stop('Please provide proper data for the alpha mating type')
}
resistance_matrix <- alpha_resistance_matrix
genotyping_df <- alpha_genotyping_df
}else{
stop('Invalid mating type(s) provided')
}
initial_lm <- create_resistance_lm(genes_A,
resistance_matrix = resistance_matrix,
genotyping_df = genotyping_df,
drug_name=drug,
mating_type=mating_type)
marginal_lm <- stepwise_feature_elimination_lm(initial_lm,alpha = sig_threshold_marginal)
print(marginal_lm)
}
}
}
eyo <- create_all_lms(A_resistance_matrix = resistance_A, alpha_resistance_matrix = resistance_alpha, A_genotyping_df = genotyping_results_A, alpha_genotyping_df = genotyping_results_alpha)
?Anova
#############################################
###Functions to help with linear regression##
#############################################
#' Calculates p value of an overlap between two sets
#'
#' @param n_overlap how many objects the two sets have in common
#' @param set_size1 how many objects in the first set
#' @param set_size2 how many objects in the second set
#' @param universe_size how many objects in the 'universe', i.e. the size
#' of all possible things both sets could have sampled
#'
#' @return a p value calculated using the Hypergeometric test
set_overlap_p <- function(n_overlap,set_size1,set_size2,universe_size){
return(phyper(n_overlap-1,
set_size1,
universe_size - set_size1,
set_size2, lower.tail=F))
}
#' Create all possible binary numbers of length 'size', represented in a matrix
#'
#' @param size the length of vector required
#'
#' @return a matrix of all binary numbers of length 'size', with one number represented as a vector on each row
all_binary_numbers <- function(size){
#A helper function to create a vector of 1s and 0s
#repeating 1 'repetition' times, then 0 'repetition'
#times until the required lengthof the vector ('size') is fulfilled
#
#Fails if 'repetition' is not a factor of 'size'
.level_representation <- function(size,repetition){
as.vector(sapply(1:(size/repetition),simplify='array',function(x){
if(x %% 2 == 0){
return(rep(0,repetition))
}
return(rep(1,repetition))
}))
}
df <- c()
for(i in 1:size){
df <- cbind(df,.level_representation(2^size,2^(i-1)))
}
return(df)
}
#' Return an expanded matrix representing all interaction terms specified
#'
#' @param terms interaction terms and genes as a vector,
#' split by a ':', e.g. c('A','B','C','A:B','A:C','B:C','A:B:C')
#' @param input_file a file which has as the set of all names
#' defined in the interaction terms as column names
#' and each row is an observation where each name takes either
#' 0 or 1 as its value
#
#' @return a matrix which each interaction given is represented
#' by a separate column. Each interaction term is given by multiplying
#' the values of its consistuent terms
create_interaction_matrix <- function(terms,input_file){
returned_df <- sapply(terms,function(term){
genes <- strsplit(term,split=":")[[1]]
apply(input_file[,genes,drop=F],1,prod)
})
colnames(returned_df) <- terms
return(returned_df)
}
#' Convert a factor, or a vector of discrete values, to a matrix of zeroes
#' and ones representing the identity of each level (i.e. a 'one-hot encoding' matrix)
#'
#' @param terms a vector or factor object, in the same order as it appears
#' as rows in the 'input_df'
#' @param input_df the data frame or matrix from which the vector terms were extracted from,
#' with corresponding row names for each measurement
#'
#' @return a 'one-hot' encoding matrix of the factors with the row names supplied fom input_df
factor_to_matrix_represenation <- function(terms,input_df){
result <- c()
unique_terms <- unique(terms)
for(unique_term in unique_terms){
result <- cbind(result,as.numeric(terms==unique_term))
}
rownames(result) <- rownames(input_df)
colnames(result) <- unique_terms
return(result)
}
#' Get string corresponding to interactions of degree n amongst given variables
#'
#' @param variable_names the names of variables to be expanded into interactions
#' @param degree the degree of interactions desired
#'
#' @return a vector of strings in A:B:C...etc format
get_interactions <- function(variable_names,degree){
all_combos <- combn(variable_names,degree)
return(apply(all_combos,2,function(x){paste(x,collapse=':')}))
}
#' Perform stepwise feature elimination on a linear regression model using Type III SS Anova
#'
#' @param my_lm a linear model object
#' @param alpha the minimum p value of variables to keep
#' @param given_data the source data on which my_lm was trained on, if NULL (default) tries to extract it from the lm object
#'
#' @return a new linear model with all variables with significance less than alpha removed in a stepwise fashion
stepwise_feature_elimination_lm <- function(my_lm,alpha=0.05,given_data=NULL){
if(is.null(given_data)){
given_data <- my_lm$model
}
my_anova_lm <- car::Anove(my_lm,type='III')
max_p <- max(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)],na.rm=T)
while(max_p > alpha){
#Exclude Intercept and residual terms from min
max_p <- max(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)],na.rm=T)
#Remove according coefficient
coefficients <- rownames(my_anova_lm)[2:(nrow(my_anova_lm))]
coefficients <- coefficients[!(1:length(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)]) %in% which.min(abs(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)] - min_val)))]
coefficients <- coefficients[!(coefficients %in% c('Residuals','(Intercept)'))]
coefficients <- coefficients[!is.na(coefficients)]
print(paste(c('resistance~',paste(c(coefficients),collapse='+')),collapse=''))
formula <- as.formula(paste(c('resistance~',paste(c(coefficients),collapse='+')),collapse=''))
my_lm <- lm(formula,data=given_data)
my_anova_lm <- car::Anove(my_lm,type='III')
max_p <- max(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)],na.rm=T)
}
return(my_lm)
}
create_resistance_lm <- function(terms,
resistance_matrix,
genotyping_df,
drug_name,
mating_type,
genotyping_columns=2:17){
name <- paste(c(drug,mating_type),collapse='_')
genotyping_results <- genotyping_df[,genotyping_columns]
genotype_terms <- create_interaction_matrix(terms,genotyping_results)
lm_df <- as.data.frame(cbind(as.data.frame(resistance_matrix[,name]),
genotyping_df$Plate,
as.data.frame(genotype_terms)))
colnames(lm_df)[1:2] <- c('resistance','Plate')
lm_formula <- as.formula(paste(c('resistance~',paste(c(terms,'Plate'),collapse='+')),collapse=''))
return(lm(lm_formula,data=lm_df))
}
create_all_lms <- function(drugs='tamoxifen',
mating_types=c('A','alpha'),
A_resistance_matrix=NULL,
alpha_resistance_matrix=NULL,
A_genotyping_df=NULL,
alpha_genotyping_df=NULL,
maximum_degree=4,
genotyping_columns=2:17,
genes_considered='all',
sig_threshold_marginal=0.05
){
results <- list('lm_list'=list(),
'term_names'=list()
)
if(length(mating_types) == 2){
results$overap_results <- list()
results$term_overlap_significance <- list()
}
if(genes_considered == 'all'){
if('A' %in% mating_types){
genes_A <- colnames(A_genotyping_df)[genotyping_columns]
}
if('alpha' %in% mating_types){
genes_alpha <- colnames(alpha_genotyping_df)[genotyping_columns]
}
if(length(mating_types) == 2){
if(all.equal(genes_A,genes_alpha) != TRUE){
stop('Genotyping columns differ between A and alpha')
}
}
}
for(drug in drugs){
for(mating_type in mating_types){
if(mating_type=='A'){
if(is.null(A_resistance_matrix) | is.null(A_genotyping_df)){
stop('Please provide proper data for the A mating type')
}
resistance_matrix <- A_resistance_matrix
genotyping_df <- A_genotyping_df
}else if(mating_type == 'alpha'){
if(is.null(alpha_resistance_matrix) | is.null(alpha_genotyping_df)){
stop('Please provide proper data for the alpha mating type')
}
resistance_matrix <- alpha_resistance_matrix
genotyping_df <- alpha_genotyping_df
}else{
stop('Invalid mating type(s) provided')
}
initial_lm <- create_resistance_lm(genes_A,
resistance_matrix = resistance_matrix,
genotyping_df = genotyping_df,
drug_name=drug,
mating_type=mating_type)
marginal_lm <- stepwise_feature_elimination_lm(initial_lm,alpha = sig_threshold_marginal)
print(marginal_lm)
}
}
}
eyo <- create_all_lms(A_resistance_matrix = resistance_A, alpha_resistance_matrix = resistance_alpha, A_genotyping_df = genotyping_results_A, alpha_genotyping_df = genotyping_results_alpha)
#############################################
###Functions to help with linear regression##
#############################################
#' Calculates p value of an overlap between two sets
#'
#' @param n_overlap how many objects the two sets have in common
#' @param set_size1 how many objects in the first set
#' @param set_size2 how many objects in the second set
#' @param universe_size how many objects in the 'universe', i.e. the size
#' of all possible things both sets could have sampled
#'
#' @return a p value calculated using the Hypergeometric test
set_overlap_p <- function(n_overlap,set_size1,set_size2,universe_size){
return(phyper(n_overlap-1,
set_size1,
universe_size - set_size1,
set_size2, lower.tail=F))
}
#' Create all possible binary numbers of length 'size', represented in a matrix
#'
#' @param size the length of vector required
#'
#' @return a matrix of all binary numbers of length 'size', with one number represented as a vector on each row
all_binary_numbers <- function(size){
#A helper function to create a vector of 1s and 0s
#repeating 1 'repetition' times, then 0 'repetition'
#times until the required lengthof the vector ('size') is fulfilled
#
#Fails if 'repetition' is not a factor of 'size'
.level_representation <- function(size,repetition){
as.vector(sapply(1:(size/repetition),simplify='array',function(x){
if(x %% 2 == 0){
return(rep(0,repetition))
}
return(rep(1,repetition))
}))
}
df <- c()
for(i in 1:size){
df <- cbind(df,.level_representation(2^size,2^(i-1)))
}
return(df)
}
#' Return an expanded matrix representing all interaction terms specified
#'
#' @param terms interaction terms and genes as a vector,
#' split by a ':', e.g. c('A','B','C','A:B','A:C','B:C','A:B:C')
#' @param input_file a file which has as the set of all names
#' defined in the interaction terms as column names
#' and each row is an observation where each name takes either
#' 0 or 1 as its value
#
#' @return a matrix which each interaction given is represented
#' by a separate column. Each interaction term is given by multiplying
#' the values of its consistuent terms
create_interaction_matrix <- function(terms,input_file){
returned_df <- sapply(terms,function(term){
genes <- strsplit(term,split=":")[[1]]
apply(input_file[,genes,drop=F],1,prod)
})
colnames(returned_df) <- terms
return(returned_df)
}
#' Convert a factor, or a vector of discrete values, to a matrix of zeroes
#' and ones representing the identity of each level (i.e. a 'one-hot encoding' matrix)
#'
#' @param terms a vector or factor object, in the same order as it appears
#' as rows in the 'input_df'
#' @param input_df the data frame or matrix from which the vector terms were extracted from,
#' with corresponding row names for each measurement
#'
#' @return a 'one-hot' encoding matrix of the factors with the row names supplied fom input_df
factor_to_matrix_represenation <- function(terms,input_df){
result <- c()
unique_terms <- unique(terms)
for(unique_term in unique_terms){
result <- cbind(result,as.numeric(terms==unique_term))
}
rownames(result) <- rownames(input_df)
colnames(result) <- unique_terms
return(result)
}
#' Get string corresponding to interactions of degree n amongst given variables
#'
#' @param variable_names the names of variables to be expanded into interactions
#' @param degree the degree of interactions desired
#'
#' @return a vector of strings in A:B:C...etc format
get_interactions <- function(variable_names,degree){
all_combos <- combn(variable_names,degree)
return(apply(all_combos,2,function(x){paste(x,collapse=':')}))
}
#' Perform stepwise feature elimination on a linear regression model using Type III SS Anova
#'
#' @param my_lm a linear model object
#' @param alpha the minimum p value of variables to keep
#' @param given_data the source data on which my_lm was trained on, if NULL (default) tries to extract it from the lm object
#'
#' @return a new linear model with all variables with significance less than alpha removed in a stepwise fashion
stepwise_feature_elimination_lm <- function(my_lm,alpha=0.05,given_data=NULL){
if(is.null(given_data)){
given_data <- my_lm$model
}
my_anova_lm <- car::Anova(my_lm,type='III')
max_p <- max(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)],na.rm=T)
while(max_p > alpha){
#Exclude Intercept and residual terms from min
max_p <- max(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)],na.rm=T)
#Remove according coefficient
coefficients <- rownames(my_anova_lm)[2:(nrow(my_anova_lm))]
coefficients <- coefficients[!(1:length(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)]) %in% which.min(abs(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)] - min_val)))]
coefficients <- coefficients[!(coefficients %in% c('Residuals','(Intercept)'))]
coefficients <- coefficients[!is.na(coefficients)]
print(paste(c('resistance~',paste(c(coefficients),collapse='+')),collapse=''))
formula <- as.formula(paste(c('resistance~',paste(c(coefficients),collapse='+')),collapse=''))
my_lm <- lm(formula,data=given_data)
my_anova_lm <- car::Anova(my_lm,type='III')
max_p <- max(my_anova_lm$Pr[2:(nrow(my_anova_lm)-1)],na.rm=T)
}
return(my_lm)
}
create_resistance_lm <- function(terms,
resistance_matrix,
genotyping_df,
drug_name,
mating_type,
genotyping_columns=2:17){
name <- paste(c(drug,mating_type),collapse='_')
genotyping_results <- genotyping_df[,genotyping_columns]
genotype_terms <- create_interaction_matrix(terms,genotyping_results)
lm_df <- as.data.frame(cbind(as.data.frame(resistance_matrix[,name]),
genotyping_df$Plate,
as.data.frame(genotype_terms)))
colnames(lm_df)[1:2] <- c('resistance','Plate')
lm_formula <- as.formula(paste(c('resistance~',paste(c(terms,'Plate'),collapse='+')),collapse=''))
return(lm(lm_formula,data=lm_df))
}
create_all_lms <- function(drugs='tamoxifen',
mating_types=c('A','alpha'),
A_resistance_matrix=NULL,
alpha_resistance_matrix=NULL,
A_genotyping_df=NULL,
alpha_genotyping_df=NULL,
maximum_degree=4,
genotyping_columns=2:17,
genes_considered='all',
sig_threshold_marginal=0.05
){
results <- list('lm_list'=list(),
'term_names'=list()
)
if(length(mating_types) == 2){
results$overap_results <- list()
results$term_overlap_significance <- list()
}
if(genes_considered == 'all'){
if('A' %in% mating_types){
genes_A <- colnames(A_genotyping_df)[genotyping_columns]
}
if('alpha' %in% mating_types){
genes_alpha <- colnames(alpha_genotyping_df)[genotyping_columns]
}
if(length(mating_types) == 2){
if(all.equal(genes_A,genes_alpha) != TRUE){
stop('Genotyping columns differ between A and alpha')
}
}
}
for(drug in drugs){
for(mating_type in mating_types){
if(mating_type=='A'){
if(is.null(A_resistance_matrix) | is.null(A_genotyping_df)){
stop('Please provide proper data for the A mating type')
}
resistance_matrix <- A_resistance_matrix
genotyping_df <- A_genotyping_df
}else if(mating_type == 'alpha'){
if(is.null(alpha_resistance_matrix) | is.null(alpha_genotyping_df)){
stop('Please provide proper data for the alpha mating type')
}
resistance_matrix <- alpha_resistance_matrix
genotyping_df <- alpha_genotyping_df
}else{
stop('Invalid mating type(s) provided')
}
initial_lm <- create_resistance_lm(genes_A,
resistance_matrix = resistance_matrix,
genotyping_df = genotyping_df,
drug_name=drug,
mating_type=mating_type)
marginal_lm <- stepwise_feature_elimination_lm(initial_lm,alpha = sig_threshold_marginal)
print(marginal_lm)
}
}
}
eyo <- create_all_lms(A_resistance_matrix = resistance_A, alpha_resistance_matrix = resistance_alpha, A_genotyping_df = genotyping_results_A, alpha_genotyping_df = genotyping_results_alpha)
