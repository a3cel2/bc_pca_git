iterations=1000,
node_probs=c(0:10)/10,
metric='component size',
conditions=NULL,
excluded_condition_grep='CRISPR',
n_parallel=8,
load_saved=F,
save_output=F,
save_directory=NULL,
save_filename=NULL,
seed=99){
saved_file_path <- paste(c(save_directory,save_filename),collapse='/')
if(file.exists(saved_file_path) & load_saved == T){
output_table <- read.table(saved_file_path)
colnames(output_table) <- sapply(colnames(output_table),function(x){strsplit(x,split='X')[[1]][2]})
return(as.matrix(output_table))
}
set.seed(seed)
if(is.null(conditions)){
conditions <- levels(pca_universe$Condition)
}
conditions <- conditions[!(grepl(excluded_condition_grep,conditions))]
result_matrix <- c()
cl <- snow::makeCluster(n_parallel)
for(condition in conditions){
# for(direction in c('accumulated','depleted')){
write(paste(c("working on:",condition),collapse=' '), stderr())
#if(direction == 'accumulated'){
#  pca_file <- pca_enhanced
#}
#if(direction == 'depleted'){
#  pca_file <- pca_depleted
#}
sub_pca_universe <- dplyr::filter(pca_universe,Condition==condition)
val_list_enhanced <- c()
val_list_depleted <- c()
if(metric == 'density'){
observed_val_enhanced <- get_density(pca_enhanced,condition)
observed_val_depleted <- get_density(pca_depleted,condition)
}
else if(metric == 'component size'){
observed_val_enhanced <- get_largest_component_size(pca_enhanced,condition)
observed_val_depleted <- get_largest_component_size(pca_depleted,condition)
}
for(i in node_probs){
write(paste(c("current node proportion:",i),collapse=' '), stderr())
my_net <- make_network_iterations(sub_pca_universe,
pca_enhanced,
pca_depleted,
condition,
n_iters=iterations,
mode='nodewise',
node_sensitivity=1,
prob_node=i,
metric=NULL,
n_parallel=8,
cluster=cl)
#print('done')
#print(my_net)
#stop()
if(metric == 'component size'){
shuffled_vals_enhanced <- sapply(my_net,function(x){get_largest_component_from_edgelist(x$enhanced)})
shuffled_vals_depleted <- sapply(my_net,function(x){get_largest_component_from_edgelist(x$depleted)})
}
if(metric == 'density'){
shuffled_vals_enhanced <- sapply(my_net,function(x){get_density_from_edgelist(x$enhanced)})
shuffled_vals_depleted <- sapply(my_net,function(x){get_density_from_edgelist(x$depleted)})
}
val_list_enhanced <- c(val_list_enhanced,(empirical_two_tailed_p(observed_val_enhanced,shuffled_vals_enhanced)+1e-04)*sign(observed_val_enhanced-mean(shuffled_vals_enhanced)))
val_list_depleted <- c(val_list_depleted,(empirical_two_tailed_p(observed_val_depleted,shuffled_vals_depleted)+1e-04)*sign(observed_val_depleted-mean(shuffled_vals_depleted)))
}
result_matrix <- rbind(result_matrix,val_list_enhanced)
rownames(result_matrix)[nrow(result_matrix)] <- paste(c(condition,'enhanced'),collapse=' ')
result_matrix <- rbind(result_matrix,val_list_depleted)
rownames(result_matrix)[nrow(result_matrix)] <- paste(c(condition,'depleted'),collapse=' ')
#}
}
colnames(result_matrix) <- node_probs
snow::stopCluster(cl)
if(save_output == T){
write.table(result_matrix,file=saved_file_path)
}
return(result_matrix)
}
#' A histogram of edgewise-shuffled largest component size iterations
#'
#' @param pca_universe A PCA file corresponding to all protein-protein interactions
#' available in a given condition
#' @param pca_enhanced A PCA file corresponding to all significantly enhanced
#' protein-protein interactions
#' @param pca_depleted A PCA file corresponding to all significantly depleted
#' protein-protein interactions
#' @param condition condition, a string
#' @param iterations number of iterations to plot in the histogram
#' @param metric the metric to be tested, defaults to largest connected component size
#' @param seed seed for the random number generator
#'
#' @return plots a histogram
connectivity_histogram <- function(pca_universe,
pca_enhanced,
pca_depleted,
condition,
iterations=10000,
metric = get_largest_component_from_edgelist,
seed=123,
text_size=1.5,
xlim=c(0,25),
breakstep=1,
xlab='Simulated largest component',
sampling_mode='edgewise',
prob_node=0){
set.seed(seed)
par(mfrow=c(1,2),
mar=c(6,4.5,3,0),
oma=c(0,0,0,0))
edgelist_enhanced <- as.matrix(dplyr::filter(pca_enhanced,Condition==condition)
%>% dplyr::select(ORF.1,ORF.2))
edgelist_depleted <- as.matrix(dplyr::filter(pca_depleted,Condition==condition)
%>% dplyr::select(ORF.1,ORF.2))
largest_component_enhanced <- metric(edgelist_enhanced)
largest_component_depleted <- metric(edgelist_depleted)
shuffled_iters <- unlist(make_network_iterations(pca_universe,
pca_enhanced,
pca_depleted,
condition,
n_iters=iterations,
metric = metric,
prob_node=prob_node,
mode=sampling_mode))
print(shuffled_iters[names(shuffled_iters)=='enhanced'])
#plot(density(shuffled_iters,from=0,to=largest_component+largest_component*0.1),xlim=c(min(shuffled_iters),largest_component+largest_component*0.05))
my_hist_enh <- hist(shuffled_iters[names(shuffled_iters)=='enhanced'],
breaks=seq(0,max(shuffled_iters) + 0.1*max(shuffled_iters),by=breakstep),
cex.lab=text_size,
plot=F)
my_hist_depl <- hist(shuffled_iters[names(shuffled_iters)=='depleted'],
breaks=seq(0,max(shuffled_iters) + 0.1*max(shuffled_iters),by=breakstep),
cex.lab=text_size,
plot=F)
histlist <- list('accumulated'=list('histvar'=my_hist_enh,
'largest_component'=largest_component_enhanced),
'depleted'=list('histvar'=my_hist_depl,
'largest_component'=largest_component_depleted))
for(i in 1:length(histlist)){
hist <- histlist[[i]]
my_hist <- hist$histvar
direction <- names(histlist)[i]
plot(my_hist,
xlim=xlim,
xlab=xlab,
ylim=c(0,max(my_hist$counts)*1.33),
main='',
ylab='Frequency',
col='black',
cex.lab=1.3)
abline(v=hist$largest_component,lwd=6,col=rgb(1,0,0,0.7))
text(hist$largest_component,mean(c(max(my_hist$counts),max(my_hist$counts)*1.3)),'Observed',srt=90,adj=c(0.5,1.5),col='gray60',cex=1.3,font=2)
mtext(paste(c(Hmisc::capitalize(condition),direction,'\ncomplexes'),collapse=' '),side=3,cex=1.5,line=-1)
}
#}
}
#' Returns a heatmap which plots the output from network_simulation_significance_node_edge_search_matrix
#' @param node_edge_sig_matrix the output from network_simulation_significance_node_edge_search_matrix,
#' where the rows correspond to conditions x directions and the columns are given proportions of node-based changes,
#' values are either 1 (significant, real value is greater than simulations), 0 (nonsigificant), -1
#' (significant, real value is less than simulations)
#' @param my_color_function a gradient generating function, the first value will be used for -1 values in matrix,
#' the middle for 0 values, the last for 1 values
#' @param legend_labels vector of form c('-1'=label1,'0'=label2,'1'=label3,2=label4)
#' @param x_label the title to be plotted on the X axis
#' @param y_label the title to be plotted on the Y axis
#' @param border_colour border outline colour
#' @param border_size border outline width
#' @param conditions_plotted conditions to include, if NULL plots all conditions
#'
#' @return plots a heatmap
node_edge_search_heatmap <- function(node_edge_sig_matrix,
condition_delimiter=' ',
conditions_plotted=NULL,
collapse_enh_depl=T,
my_color_function,
legend_labels=c('-1'="Large component sizes (p < 0.05)",
'0'="Expected component sizes",
'1'="Small component sizes (p < 0.05)",
'2'="Most consistent simulation"),
x_label='',
y_label='Proportion of Protein-\nCentered Complex Changes',
border_colour='grey40',
zero_colour='grey90',
border_size=0.25,
width=0.7,
top_label='Protein-Centric\nModel',
bottom_label='Interaction-Specific\nModel',
right_margin=11){
my_matr <- node_edge_sig_matrix
print('here')
print(my_matr)
my_matr.m <- reshape2::melt(my_matr)
colnames(my_matr.m) <- c('Condition','PercentNodes','value')
my_matr.m[,3] <- as.character(my_matr.m[,3])
my_matr.m[,2] <- as.character(my_matr.m[,2])
##Ggvis2 version
#   my_matr.m %>%
#     ggvis(~PercentNodes,~Condition,fill=~value) %>%
#     layer_rects(width = band(), height = band()) %>%
#     scale_nominal("x", padding = 0, points = FALSE) %>%
#     scale_nominal("y", padding = 0, points = FALSE) %>%
#     add_axis("x",
#              offset=-10,
#              orient = "top",
#              title = 'Proportion of Node-Based Changes',
#              title_offset = 50,
#              properties=axis_props(
#                axis=list(strokeWidth=0),
#                grid=list(strokeWidth=0),
#                ticks=list(strokeWidth=0),
#                labels=list(angle=90,fontSize=15,align="right"),
#                title=list(fontSize=20)
#              )) %>%
#     add_axis("y",
#              title_offset = 170,
#              properties=axis_props(
#                axis=list(strokeWidth=0),
#                ticks=list(strokeWidth=0),
#                labels=list(fontSize = 15),
#                title=list(fontSize=20))
#              )
cols <- my_color_function(10)
if(is.null(zero_colour)){
zero_colour = cols[3]
}
myplot <- ggplot2::ggplot(data = my_matr.m, ggplot2::aes(x=Condition, y=PercentNodes, fill=factor(value))) +
ggplot2::geom_tile(color=border_colour,size=border_size,width=width) +
ggplot2::scale_fill_manual(values=c('-1'=cols[9],'0'=zero_colour,'1'=cols[2],'2'='black'),
labels = legend_labels,
guide = ggplot2::guide_legend(reverse = TRUE, title='')) +
ggplot2::xlab(x_label) +
ggplot2::ylab(y_label) +
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1, vjust = 0.5),
panel.background = ggplot2::element_rect(fill = "white"),
panel.grid = ggplot2::element_line(size = 0),
axis.title = ggplot2::element_text(size=ggplot2::rel(1.5)),
axis.text = ggplot2::element_text(size=ggplot2::rel(1.1)),
legend.text = ggplot2::element_text(size=ggplot2::rel(1.1)),
legend.key.height=ggplot2::unit(1.5,"line"),
legend.key.width=ggplot2::unit(1.5,"line"),
legend.position='right',
plot.margin = ggplot2::unit(c(1,right_margin,1,1), "lines")) +
ggplot2::coord_equal()
#ggplot2::coord_flip()
myplot <- myplot + ggplot2::annotation_custom(grob = grid::textGrob(label=bottom_label,just='left'),
ymin=1,
ymax=1,
xmin=nrow(my_matr)+1,
xmax=nrow(my_matr)+1)
myplot <- myplot + ggplot2::annotation_custom(grob = grid::textGrob(label=top_label,just='left'),
ymin=ncol(my_matr),
ymax=ncol(my_matr),
xmin=nrow(my_matr)+1,
xmax=nrow(my_matr)+1)
p <- myplot
gt <- ggplot2::ggplot_gtable(ggplot2::ggplot_build(p))
gt$layout$clip[gt$layout$name == "panel"] <- "off"
grid::grid.draw(gt)
#return(myplot)
}
filter_matching_conditions <- function(node_edge_sig_matrix,conditions_plotted){
condnames <- rownames(node_edge_sig_matrix)
match_matr <- sapply(condnames,function(x){
sapply(conditions_plotted,function(condition){
sum(grepl(condition,x))
})
})
return(node_edge_sig_matrix[apply(match_matr,2,sum) > 0,])
}
process_node_edge_sig_matrix <- function(node_edge_sig_matrix,conditions_plotted,collapse_enh_depl=T){
#Filter out given conditions e.g. if they have only a few changes
if(!is.null(conditions_plotted)){
node_edge_sig_matrix <- filter_matching_conditions(node_edge_sig_matrix,conditions_plotted)
}
if(collapse_enh_depl == T){
node_edge_sig_matrix <- t(sapply(conditions_plotted,function(condition){
matching_rows <- node_edge_sig_matrix[grep(condition,rownames(node_edge_sig_matrix)),]
apply(matching_rows,2,function(x){x[which.min(abs(x))]})
}))
}
#For colour encoding
#eyo <<- node_edge_sig_matrix
node_edge_sig_matrix[t(apply(node_edge_sig_matrix,1,function(x){abs(x)==max(abs(x))}))] <- 4
node_edge_sig_matrix[node_edge_sig_matrix < 0.05 & node_edge_sig_matrix > 0] <- 2
node_edge_sig_matrix[node_edge_sig_matrix > -0.05 & node_edge_sig_matrix < 0] <- 3
node_edge_sig_matrix[!(node_edge_sig_matrix %in% c(2,3,4))] <- 0
node_edge_sig_matrix[node_edge_sig_matrix == 2] <- 1
node_edge_sig_matrix[node_edge_sig_matrix == 3] <- -1
node_edge_sig_matrix[node_edge_sig_matrix == 4] <- 2
return(node_edge_sig_matrix)
}
hub_bias_heatmap <- function(hub_df,
color_function,
legend_labels=c('-1'="Complex\ndepletion bias",
'0'="Non-significant\nbias",
'1'="Complex\naccumulation bias"),
border_colour= 'grey40',
border_size = 0.25,
legend_position=c(1,1),
legend_justification=c(0,1),
nonsig_colour='grey10',
q_cutoff = 0.05
){
#Format hub dataframe for plotting
new_hub_df <- select(hub_df,Hub,Condition,q.value.BH.)
new_hub_df[,3] <- as.numeric(new_hub_df[,3] < q_cutoff)
new_hub_df[,3] <- new_hub_df[,3]*sign(hub_df$Delta)
new_hub_df[,3][is.na(hub_df[,3])] <- 0
colnames(new_hub_df)[3] <- 'value'
#Number of nonzero conditions
sorted_new_hub_df <- as.data.frame(new_hub_df %>% dplyr::group_by(Hub) %>% dplyr::summarize(nzero=sum(abs(value))))
hub_count_list <- unlist(apply(sorted_new_hub_df,1,function(x){
retval <- list()
retval[x[1]] <- as.numeric(x[2])
#names(retval) <- x[1]
return(retval)
}))
sorted_hubs <- sorted_new_hub_df[,'Hub'][sort(sorted_new_hub_df[,'nzero'],index.return=T,decreasing=F)$ix]
sorted_new_hub_df <- as.data.frame(new_hub_df %>% dplyr::group_by(Condition) %>% dplyr::summarize(nzero=sum(abs(value))))
sorted_conditions <- sorted_new_hub_df[,'Condition'][sort(sorted_new_hub_df[,'nzero'],index.return=T,decreasing=T)$ix]
new_hub_df[,'Hub'] <- factor(new_hub_df[,'Hub'],levels=sorted_hubs)
new_hub_df[,'Condition'] <- factor(new_hub_df[,'Condition'],levels=sorted_conditions)
new_hub_df <- dplyr::filter(new_hub_df, Hub %in% names(which(hub_count_list > 0)))
new_hub_df[,'value'] <- as.factor(new_hub_df[,'value'])
#new_hub_df <- as.data.frame(t(new_hub_df))
cols <- color_function(10)
myplot <- ggplot2::ggplot(data = new_hub_df, ggplot2::aes(y=Hub, x=Condition, fill=value)) +
ggplot2::geom_tile(ggplot2::aes(fill = value),color=border_colour,size=border_size) +
ggplot2::coord_equal() +
ggplot2::scale_fill_manual(
labels = legend_labels,
values=c('-1'=cols[2],'0'=nonsig_colour,'1'=cols[9]),
guide = ggplot2::guide_legend(title='')) +
ggplot2::theme(axis.title.x = ggplot2::element_text(
#face="bold",
size=15,
vjust=0),
axis.title.y = ggplot2::element_text(size=20
#face="bold"
),
axis.title.x = ggplot2::element_text(size=50
#face="bold"
),
axis.text.x  = ggplot2::element_text(angle=90,
hjust=1,
vjust=0.5,
size=10),
axis.text.y = ggplot2::element_text(size=10),
legend.text = ggplot2::element_text(size=ggplot2::rel(1)),
legend.position=legend_position,
legend.justification=legend_justification,
legend.key.width=unit(2, "lines"),
legend.key.height=unit(2, "lines"),
plot.margin = unit(c(0.5, 7, 0, 0), "lines"))
plot(myplot)
}
bias_over_conditions <- function(hub_df,
p_cutoff=0.05,
title="Proportion of concerted hubs\nover different conditions"){
conditions <- levels(hub_df$Condition)
hub_proportion <- sapply(conditions,function(condition){
subset_df <- dplyr::filter(hub_df,Condition==condition)
all_hubs <- unique(subset_df$Hub)
cond_hubs <- unique(filter(subset_df,q.value.BH. < p_cutoff)$Hub)
return(length(cond_hubs)/length(all_hubs))
})
hub_proportion <- as.data.frame(hub_proportion)
hub_proportion <- cbind(rownames(hub_proportion),hub_proportion)
colnames(hub_proportion) <- c('Condition','Proportion of Concerted Hubs')
order <- sort(hub_proportion$`Proportion of Concerted Hubs`,
index.return=T,
decreasing=T)$ix
#hub_proportion <- hub_proportion[order,]
hub_proportion$Condition <- factor(hub_proportion$Condition,
levels=hub_proportion$Condition[order])
#levels(hub_proportion$Condition) <- hub_proportion$Condition[order]
ggplot2::ggplot(data=hub_proportion,ggplot2::aes(x=Condition,
y=`Proportion of Concerted Hubs`,width=.7)) +
ggplot2::ggtitle(title) +
ggplot2::ylab('Proportion of Concerted Hubs\n') +
ggplot2::xlab('\nConditions') +
ggplot2::geom_bar(stat="identity",fill="snow4",colour="black") +
ggplot2::scale_y_continuous(expand = c(0,0),
limits=c(0,max(hub_proportion$`Proportion of Concerted Hubs`)*1.05)) +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "white"),
legend.position=c(0.8,0.8),
#legend.text = ggplot2::element_text(size=15),
legend.title = ggplot2::element_text(size=20,hjust=0),
text = ggplot2::element_text(size=20),
axis.text.x = ggplot2::element_text(angle=90, hjust=1,vjust=0.5),
axis.line.x = ggplot2::element_line(size = 1, linetype = "solid", colour = "black"),
axis.line.y = ggplot2::element_line(size = 1, linetype = "solid", colour = "black"))
}
keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$enhanced))
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$enhanced)))
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$depleted)))
derp <- nodewise_simulation(universe_matrix,
matched_empty_matrix,
n_edges_enhanced,
n_edges_depleted,
nodelist,
prob_node=prob_node)
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$depleted)))
derp <- nodewise_simulation(universe_matrix,
matched_empty_matrix,
n_edges_enhanced,
n_edges_depleted,
nodelist,
prob_node=prob_node)
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$depleted)))
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$enhanced)))
apply(derp$depleted,1,function(x){paste(c(x,'depleted'))}
)
rbind(apply(derp$depleted,1,function(x){paste(c(x,'depleted'))}),apply(derp$enhanced,1,function(x){paste(c(x,'enhanced'))}))
cbind(apply(derp$depleted,1,function(x){paste(c(x,'depleted'))}),apply(derp$enhanced,1,function(x){paste(c(x,'enhanced'))}))
t(cbind(apply(derp$depleted,1,function(x){paste(c(x,'depleted'))}),apply(derp$enhanced,1,function(x){paste(c(x,'enhanced'))})))
setwd()
getwd()
setwd('../results/external_graphics/node_edge_simulation')
out_matr <- t(cbind(apply(derp$depleted,1,function(x){paste(c(x,'depleted'))}),apply(derp$enhanced,1,function(x){paste(c(x,'enhanced'))})))
write.table(out_matr)
write.table(out_matr,row.names=F)
write.table(out_matr,row.names=F,col.names=F)
write.table(out_matr,row.names=F,col.names=F,quote=F)
write.table(out_matr,row.names=F,col.names=F,quote=F,sep='\t')
write.table(out_matr,row.names=F,col.names=F,quote=F,sep='\t',file='doxo_simulation.tsv')
igraph::graph_from_edgelist(derp$depleted)
keep_only_largest_component(igraph::graph_from_edgelist(derp$depleted))
keep_only_largest_connected_component <- function(graph){
components <- igraph::clusters(graph)
largest_component <- which.max(components$csize)
vertices_in_other_components <- names(which(components$membership != largest_component))
new_graph <- igraph::delete.vertices(graph,vertices_in_other_components)
return(new_graph)
}
keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$depleted))
edges(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$depleted)))
keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$depleted))$edges
derp <- keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$depleted))
edgelist(derp)
derp <- nodewise_simulation(universe_matrix,
matched_empty_matrix,
n_edges_enhanced,
n_edges_depleted,
nodelist,
prob_node=prob_node)
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$enhanced)))
derp <- nodewise_simulation(universe_matrix,
matched_empty_matrix,
n_edges_enhanced,
n_edges_depleted,
nodelist,
prob_node=prob_node)
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$enhanced)))
derp <- nodewise_simulation(universe_matrix,
matched_empty_matrix,
n_edges_enhanced,
n_edges_depleted,
nodelist,
prob_node=prob_node)
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$enhanced)))
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$depleted)))
derp <- nodewise_simulation(universe_matrix,
matched_empty_matrix,
n_edges_enhanced,
n_edges_depleted,
nodelist,
prob_node=prob_node)
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$depleted)))
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$enhanced)))
e_d <- keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$depleted))
e_e <- keep_only_largest_connected_component(igraph::graph_from_edgelist(derp$enhanced))
e_d
E(e_e)
as.matrix(E(e_e))
out_matr <- t(cbind(apply(derp$depleted,1,function(x){paste(c(x,'depleted'))}),apply(derp$enhanced,1,function(x){paste(c(x,'enhanced'))})))
write.table(out_matr,row.names=F,col.names=F,quote=F,sep='\t',file='doxo_simulation.tsv')
map_gene_names(out_matr[,1])
cbind(map_gene_names(out_matr[,1]),map_gene_names(out_matr[,2]))
cbind(map_gene_names(out_matr[,1]),map_gene_names(out_matr[,2]),out_matr[,3])
out_matr_2 <- cbind(map_gene_names(out_matr[,1]),map_gene_names(out_matr[,2]),out_matr[,3])
write.table(oout_matr_2,row.names=F,col.names=F,quote=F,sep='\t',file='doxo_simulation.tsv')
write.table(out_matr_2,row.names=F,col.names=F,quote=F,sep='\t',file='doxo_simulation.tsv')
derp_edge <- nodewise_simulation(universe_matrix,
matched_empty_matrix,
n_edges_enhanced,
n_edges_depleted,
nodelist,
prob_node=0)
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp_edge$depleted)))
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp_edge$enhanced)))
derp_edge <- nodewise_simulation(universe_matrix,
matched_empty_matrix,
n_edges_enhanced,
n_edges_depleted,
nodelist,
prob_node=0)
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp_edge$enhanced)))
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp_edge$depleted)))
plot(keep_only_largest_connected_component(igraph::graph_from_edgelist(derp_edge$enhanced)))
out_matr_3 <- t(cbind(apply(derp_edge$depleted,1,function(x){paste(c(x,'depleted'))}),apply(derp_edge$enhanced,1,function(x){paste(c(x,'enhanced'))})))
out_matr_4 <- cbind(map_gene_names(out_matr_3[,1]),map_gene_names(out_matr_3[,2]),out_matr_3[,3])
write.table(out_matr_4,row.names=F,col.names=F,quote=F,sep='\t',file='doxo_simulation_edge.tsv')
map_gene_names('YDR032C')
map_gene_names('YML016C')
